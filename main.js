/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AttachmentManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  scopeMode: "vault",
  watchedPaths: ["Projects/Active"],
  defaultNamePattern: "${filename} ${original}",
  defaultPathPattern: "./attachments",
  enableAutoRename: true,
  debounceDelay: 2e3,
  rules: [
    {
      id: "default-image",
      label: "Images",
      extensions: ["png", "jpg", "jpeg", "gif", "webp", "svg", "bmp"],
      namePattern: "${filename} ${original}",
      pathPattern: "./assets",
      locationMode: "pattern"
    },
    {
      id: "default-pdf",
      label: "PDFs",
      extensions: ["pdf"],
      namePattern: "${filename} ${original}",
      pathPattern: "Documents/Attachments",
      locationMode: "pattern"
    }
  ]
};
var AttachmentManagerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    // Locks to prevent infinite loops
    this.isProcessing = /* @__PURE__ */ new Set();
    // Map to hold debounced functions per file path. 
    this.debouncers = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "rename-attachments-active",
      name: "Rename attachments for active note",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            if (!this.isScopeValid(file.path)) {
              new import_obsidian.Notice("Note is outside the configured scope.");
              return;
            }
            this.processNoteAttachments(file, null);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "rename-attachments-all",
      name: "Rename attachments for all notes in scope",
      callback: async () => {
        await this.processAllNotesInScope();
      }
    });
    this.addSettingTab(new AttachmentSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (!this.settings.enableAutoRename)
          return;
        if (file instanceof import_obsidian.TFile && file.extension === "md") {
          if (this.isScopeValid(file.path)) {
            const oldNoteName = this.getFileNameFromPath(oldPath);
            this.triggerDebouncedProcessing(file, oldNoteName);
          }
        }
      })
    );
    console.log("[Attachment Manager] Plugin Loaded");
  }
  async onunload() {
    for (const debouncer of this.debouncers.values()) {
      debouncer.cancel();
    }
    this.debouncers.clear();
    this.isProcessing.clear();
  }
  getFileNameFromPath(path) {
    const parts = path.split("/");
    const fileNameWithExt = parts[parts.length - 1];
    return fileNameWithExt.replace(/\.md$/, "");
  }
  triggerDebouncedProcessing(file, oldNoteName) {
    let debouncer = this.debouncers.get(file.path);
    if (!debouncer) {
      debouncer = (0, import_obsidian.debounce)(
        (f, oldName) => {
          this.processNoteAttachments(f, oldName);
          this.debouncers.delete(f.path);
        },
        this.settings.debounceDelay,
        true
      );
      this.debouncers.set(file.path, debouncer);
    }
    debouncer(file, oldNoteName);
  }
  async processAllNotesInScope() {
    const allFiles = this.app.vault.getMarkdownFiles();
    const filesInScope = allFiles.filter((file) => this.isScopeValid(file.path));
    if (filesInScope.length === 0) {
      new import_obsidian.Notice("No notes found in the configured scope");
      return;
    }
    new import_obsidian.Notice(`Processing ${filesInScope.length} notes...`);
    let totalRenamed = 0;
    for (const file of filesInScope) {
      const count = await this.processNoteAttachments(file, null);
      totalRenamed += count;
    }
    new import_obsidian.Notice(`\u2705 Processed ${filesInScope.length} notes, renamed ${totalRenamed} attachments`);
  }
  /**
   * Main Logic: Process the note and rename its embeds/links
   */
  async processNoteAttachments(noteFile, oldNoteName) {
    if (this.isProcessing.has(noteFile.path))
      return 0;
    this.isProcessing.add(noteFile.path);
    try {
      let cache = this.app.metadataCache.getFileCache(noteFile);
      let retries = 0;
      const maxRetries = 10;
      while (!cache && retries < maxRetries) {
        await new Promise((resolve) => setTimeout(resolve, 100));
        cache = this.app.metadataCache.getFileCache(noteFile);
        retries++;
      }
      if (!cache)
        return 0;
      const combinedReferences = [
        ...cache.embeds || [],
        ...cache.links || []
      ];
      if (combinedReferences.length === 0)
        return 0;
      const targets = [];
      for (let i = 0; i < combinedReferences.length; i++) {
        const ref = combinedReferences[i];
        const cleanLink = ref.link.split("#")[0].split("^")[0];
        const attachmentFile = this.app.metadataCache.getFirstLinkpathDest(cleanLink, noteFile.path);
        if (attachmentFile instanceof import_obsidian.TFile && attachmentFile.extension !== "md" && attachmentFile.path !== noteFile.path) {
          targets.push({
            file: attachmentFile,
            originalPath: attachmentFile.path,
            index: i
          });
        }
      }
      if (targets.length === 0)
        return 0;
      const processedPaths = /* @__PURE__ */ new Set();
      const checkedFolders = /* @__PURE__ */ new Set();
      let renameCount = 0;
      for (const { file: attachmentFile, originalPath, index } of targets) {
        if (processedPaths.has(attachmentFile.path))
          continue;
        if (!this.app.vault.getAbstractFileByPath(attachmentFile.path))
          continue;
        const rule = this.getRuleForExtension(attachmentFile.extension);
        if (!rule && this.settings.rules.length > 0)
          continue;
        const namePattern = rule ? rule.namePattern : this.settings.defaultNamePattern;
        const pathPattern = rule ? rule.pathPattern : this.settings.defaultPathPattern;
        const locationMode = rule ? rule.locationMode || "pattern" : "pattern";
        const cleanOriginalBase = this.getCleanOriginalName(attachmentFile.basename, oldNoteName);
        const variables = {
          filename: noteFile.basename,
          original: cleanOriginalBase,
          extension: attachmentFile.extension,
          date: this.getFormattedDate(),
          index: (index + 1).toString().padStart(2, "0")
        };
        let newBaseName = this.sanitizeName(this.applyVariables(namePattern, variables));
        if (newBaseName.length === 0)
          newBaseName = "attachment";
        const newFileName = `${newBaseName}.${attachmentFile.extension}`;
        let targetFolderPath;
        if (locationMode === "original") {
          targetFolderPath = attachmentFile.parent ? attachmentFile.parent.path : "/";
        } else {
          targetFolderPath = this.resolveTargetPath(pathPattern, noteFile);
        }
        const desiredPath = (0, import_obsidian.normalizePath)(`${targetFolderPath}/${newFileName}`);
        if (desiredPath === attachmentFile.path) {
          processedPaths.add(attachmentFile.path);
          continue;
        }
        const finalPath = await this.resolveCollision(
          desiredPath,
          attachmentFile,
          targetFolderPath,
          newBaseName
        );
        if (finalPath === attachmentFile.path) {
          processedPaths.add(attachmentFile.path);
          continue;
        }
        try {
          if (!checkedFolders.has(targetFolderPath) && locationMode !== "original") {
            await this.ensureFolderExists(targetFolderPath);
            checkedFolders.add(targetFolderPath);
          }
          console.log(`[Attachment Manager] Renaming: ${attachmentFile.name} -> ${finalPath}`);
          await this.app.fileManager.renameFile(attachmentFile, finalPath);
          processedPaths.add(finalPath);
          renameCount++;
        } catch (err) {
          console.error(`[Attachment Manager] Error renaming ${originalPath}`, err);
        }
      }
      if (renameCount > 0) {
        console.log(`[Attachment Manager] Renamed ${renameCount} files for ${noteFile.basename}`);
      }
      return renameCount;
    } catch (e) {
      console.error("[Attachment Manager] Error:", e);
      return 0;
    } finally {
      this.isProcessing.delete(noteFile.path);
    }
  }
  getCleanOriginalName(currentBase, oldNoteName) {
    if (!oldNoteName)
      return currentBase;
    let clean = currentBase;
    if (clean.includes(oldNoteName)) {
      const escapedOld = oldNoteName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const regex = new RegExp(`[\\s-_]*${escapedOld}[\\s-_]*`, "g");
      clean = clean.replace(regex, " ").trim();
    }
    if (clean === "")
      clean = "Attachment";
    return clean;
  }
  resolveTargetPath(pathPattern, noteFile) {
    if (pathPattern.startsWith("./")) {
      const parentPath = noteFile.parent ? noteFile.parent.path : "/";
      const cleanRel = pathPattern.substring(2);
      if (parentPath === "/")
        return (0, import_obsidian.normalizePath)(cleanRel);
      return (0, import_obsidian.normalizePath)(`${parentPath}/${cleanRel}`);
    } else {
      return (0, import_obsidian.normalizePath)(pathPattern);
    }
  }
  async resolveCollision(desiredPath, currentFile, targetFolder, baseName) {
    let finalPath = desiredPath;
    let suffix = 0;
    const maxRetries = 500;
    const ext = currentFile.extension;
    while (suffix < maxRetries) {
      const existing = this.app.vault.getAbstractFileByPath(finalPath);
      if (!existing)
        return finalPath;
      if (existing.path === currentFile.path)
        return finalPath;
      suffix++;
      finalPath = (0, import_obsidian.normalizePath)(`${targetFolder}/${baseName} ${suffix}.${ext}`);
    }
    return currentFile.path;
  }
  isScopeValid(filePath) {
    const { scopeMode, watchedPaths } = this.settings;
    if (scopeMode === "vault")
      return true;
    const normalizedFilePath = (0, import_obsidian.normalizePath)(filePath);
    const validWatchedPaths = watchedPaths.map((p) => (0, import_obsidian.normalizePath)(p)).filter((p) => p !== "" && p !== "/");
    if (validWatchedPaths.length === 0)
      return true;
    const isMatch = validWatchedPaths.some(
      (folder) => normalizedFilePath === folder || normalizedFilePath.startsWith(folder + "/")
    );
    if (scopeMode === "include")
      return isMatch;
    if (scopeMode === "exclude")
      return !isMatch;
    return true;
  }
  getRuleForExtension(ext) {
    const lowerExt = ext.toLowerCase();
    return this.settings.rules.find(
      (r) => r.extensions.some((e) => e.toLowerCase() === lowerExt)
    ) || null;
  }
  applyVariables(pattern, vars) {
    return pattern.replace(/\$\{filename\}/g, vars.filename || "note").replace(/\$\{original\}/g, vars.original || "file").replace(/\$\{extension\}/g, vars.extension || "").replace(/\$\{date\}/g, vars.date || "").replace(/\$\{index\}/g, vars.index || "01");
  }
  getFormattedDate() {
    const d = new Date();
    const year = d.getFullYear();
    const month = (d.getMonth() + 1).toString().padStart(2, "0");
    const day = d.getDate().toString().padStart(2, "0");
    return `${year}${month}${day}`;
  }
  sanitizeName(name) {
    return name.replace(/[\\/:"*?<>|]+/g, "-").replace(/\s+/g, " ").trim();
  }
  async ensureFolderExists(path) {
    if (!path || path === "/" || path === ".")
      return;
    const normalized = (0, import_obsidian.normalizePath)(path);
    const existing = this.app.vault.getAbstractFileByPath(normalized);
    if (existing) {
      if (existing instanceof import_obsidian.TFolder)
        return;
      throw new Error(`Cannot create folder "${normalized}" because a file exists with that name.`);
    }
    await this.app.vault.createFolder(normalized);
  }
  async loadSettings() {
    const loaded = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded);
    if (loaded == null ? void 0 : loaded.rules) {
      this.settings.rules = loaded.rules.map((r) => ({
        ...r,
        locationMode: r.locationMode || "pattern"
      }));
    }
    if (loaded == null ? void 0 : loaded.watchedPaths)
      this.settings.watchedPaths = loaded.watchedPaths;
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AttachmentSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Attachment Manager" });
    containerEl.createEl("h3", { text: "General" });
    new import_obsidian.Setting(containerEl).setName("Enable Auto-Rename").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoRename).onChange(async (val) => {
      this.plugin.settings.enableAutoRename = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Debounce Delay (ms)").addText((text) => text.setPlaceholder("2000").setValue(String(this.plugin.settings.debounceDelay)).onChange(async (val) => {
      const num = parseInt(val);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.debounceDelay = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Scope" });
    new import_obsidian.Setting(containerEl).setName("Operation Mode").addDropdown((drop) => drop.addOption("vault", "Entire Vault").addOption("include", "Only in Watched Folders").addOption("exclude", "Everywhere EXCEPT Ignored Folders").setValue(this.plugin.settings.scopeMode).onChange(async (val) => {
      this.plugin.settings.scopeMode = val;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.scopeMode !== "vault") {
      const label = this.plugin.settings.scopeMode === "include" ? "Watched Folders" : "Ignored Folders";
      new import_obsidian.Setting(containerEl).setName(label).setDesc("One folder path per line").addTextArea((text) => text.setPlaceholder("Projects/Active").setValue(this.plugin.settings.watchedPaths.join("\n")).onChange(async (val) => {
        this.plugin.settings.watchedPaths = val.split("\n").map((x) => x.trim()).filter((x) => x);
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Extension Rules" });
    this.plugin.settings.rules.forEach((rule, idx) => {
      const ruleDiv = containerEl.createDiv();
      ruleDiv.style.borderTop = "1px solid var(--background-modifier-border)";
      ruleDiv.style.padding = "10px 0";
      new import_obsidian.Setting(ruleDiv).setName(`Rule #${idx + 1}`).setHeading().addButton((btn) => btn.setIcon("trash").setWarning().onClick(async () => {
        this.plugin.settings.rules.splice(idx, 1);
        await this.plugin.saveSettings();
        this.display();
      }));
      new import_obsidian.Setting(ruleDiv).setName("Label").addText((t) => t.setValue(rule.label).onChange(async (v) => {
        rule.label = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(ruleDiv).setName("Extensions").setDesc("e.g. png, jpg").addText((t) => t.setValue(rule.extensions.join(", ")).onChange(async (v) => {
        rule.extensions = v.split(",").map((e) => e.trim()).filter((e) => e);
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(ruleDiv).setName("Location Strategy").setDesc("Move file to pattern folder OR leave where it is.").addDropdown(
        (drop) => drop.addOption("pattern", "Move to Defined Pattern").addOption("original", "Leave in Original Folder").setValue(rule.locationMode || "pattern").onChange(async (val) => {
          rule.locationMode = val;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      if (!rule.locationMode || rule.locationMode === "pattern") {
        new import_obsidian.Setting(ruleDiv).setName("Location Pattern").setDesc('Use "./" for relative path. (e.g. ./templates)').addText((t) => t.setValue(rule.pathPattern).onChange(async (v) => {
          rule.pathPattern = v;
          await this.plugin.saveSettings();
        }));
      }
      new import_obsidian.Setting(ruleDiv).setName("Name Pattern").addText((t) => t.setValue(rule.namePattern).onChange(async (v) => {
        rule.namePattern = v;
        await this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).addButton((btn) => btn.setButtonText("+ Add Rule").setCta().onClick(async () => {
      this.plugin.settings.rules.push({
        id: Date.now().toString(),
        label: "New Rule",
        extensions: [],
        namePattern: "${filename} ${original}",
        pathPattern: "./attachments",
        locationMode: "pattern"
        // Default
      });
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHtcclxuICAgIEFwcCxcclxuICAgIFBsdWdpbixcclxuICAgIFBsdWdpblNldHRpbmdUYWIsXHJcbiAgICBTZXR0aW5nLFxyXG4gICAgVEZpbGUsXHJcbiAgICBOb3RpY2UsXHJcbiAgICBub3JtYWxpemVQYXRoLFxyXG4gICAgVEZvbGRlcixcclxuICAgIGRlYm91bmNlLFxyXG4gICAgRGVib3VuY2VyLFxyXG4gICAgVEFic3RyYWN0RmlsZVxyXG59IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8vIC0tLSBJbnRlcmZhY2VzICYgU2V0dGluZ3MgLS0tXHJcblxyXG50eXBlIFNjb3BlTW9kZSA9ICd2YXVsdCcgfCAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XHJcbnR5cGUgTG9jYXRpb25Nb2RlID0gJ3BhdHRlcm4nIHwgJ29yaWdpbmFsJzsgLy8gTmV3IG9wdGlvbiBmb3IgXCJNb3ZlXCIgdnMgXCJMZWF2ZSBhcyBpc1wiXHJcblxyXG5pbnRlcmZhY2UgQXR0YWNobWVudFJ1bGUge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIGxhYmVsOiBzdHJpbmc7XHJcbiAgICBleHRlbnNpb25zOiBzdHJpbmdbXTsgLy8gZS5nLiBbJ3BuZycsICdqcGcnXVxyXG4gICAgbmFtZVBhdHRlcm46IHN0cmluZzsgIC8vIGUuZy4gJHtmaWxlbmFtZX0tJHtpbmRleH1cclxuICAgIHBhdGhQYXR0ZXJuOiBzdHJpbmc7ICAvLyBlLmcuIC4vYXNzZXRzIE9SIGF0dGFjaG1lbnRzL2ltYWdlc1xyXG4gICAgbG9jYXRpb25Nb2RlOiBMb2NhdGlvbk1vZGU7IC8vIE5ldyBwcm9wZXJ0eVxyXG59XHJcblxyXG5pbnRlcmZhY2UgUGx1Z2luU2V0dGluZ3Mge1xyXG4gICAgc2NvcGVNb2RlOiBTY29wZU1vZGU7XHJcbiAgICB3YXRjaGVkUGF0aHM6IHN0cmluZ1tdOyBcclxuICAgIHJ1bGVzOiBBdHRhY2htZW50UnVsZVtdO1xyXG4gICAgZGVmYXVsdE5hbWVQYXR0ZXJuOiBzdHJpbmc7XHJcbiAgICBkZWZhdWx0UGF0aFBhdHRlcm46IHN0cmluZztcclxuICAgIGVuYWJsZUF1dG9SZW5hbWU6IGJvb2xlYW47XHJcbiAgICBkZWJvdW5jZURlbGF5OiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBsdWdpblNldHRpbmdzID0ge1xyXG4gICAgc2NvcGVNb2RlOiAndmF1bHQnLFxyXG4gICAgd2F0Y2hlZFBhdGhzOiBbJ1Byb2plY3RzL0FjdGl2ZSddLFxyXG4gICAgZGVmYXVsdE5hbWVQYXR0ZXJuOiAnJHtmaWxlbmFtZX0gJHtvcmlnaW5hbH0nLFxyXG4gICAgZGVmYXVsdFBhdGhQYXR0ZXJuOiAnLi9hdHRhY2htZW50cycsXHJcbiAgICBlbmFibGVBdXRvUmVuYW1lOiB0cnVlLFxyXG4gICAgZGVib3VuY2VEZWxheTogMjAwMCwgXHJcbiAgICBydWxlczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdkZWZhdWx0LWltYWdlJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdJbWFnZXMnLFxyXG4gICAgICAgICAgICBleHRlbnNpb25zOiBbJ3BuZycsICdqcGcnLCAnanBlZycsICdnaWYnLCAnd2VicCcsICdzdmcnLCAnYm1wJ10sXHJcbiAgICAgICAgICAgIG5hbWVQYXR0ZXJuOiAnJHtmaWxlbmFtZX0gJHtvcmlnaW5hbH0nLFxyXG4gICAgICAgICAgICBwYXRoUGF0dGVybjogJy4vYXNzZXRzJyxcclxuICAgICAgICAgICAgbG9jYXRpb25Nb2RlOiAncGF0dGVybidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdkZWZhdWx0LXBkZicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnUERGcycsXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IFsncGRmJ10sXHJcbiAgICAgICAgICAgIG5hbWVQYXR0ZXJuOiAnJHtmaWxlbmFtZX0gJHtvcmlnaW5hbH0nLFxyXG4gICAgICAgICAgICBwYXRoUGF0dGVybjogJ0RvY3VtZW50cy9BdHRhY2htZW50cycsXHJcbiAgICAgICAgICAgIGxvY2F0aW9uTW9kZTogJ3BhdHRlcm4nXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG59O1xyXG5cclxuaW50ZXJmYWNlIEF0dGFjaG1lbnRJbmZvIHtcclxuICAgIGZpbGU6IFRGaWxlO1xyXG4gICAgb3JpZ2luYWxQYXRoOiBzdHJpbmc7XHJcbiAgICBpbmRleDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdHRhY2htZW50TWFuYWdlclBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcbiAgICBzZXR0aW5nczogUGx1Z2luU2V0dGluZ3M7XHJcbiAgICBcclxuICAgIC8vIExvY2tzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcclxuICAgIHByaXZhdGUgaXNQcm9jZXNzaW5nID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICBcclxuICAgIC8vIE1hcCB0byBob2xkIGRlYm91bmNlZCBmdW5jdGlvbnMgcGVyIGZpbGUgcGF0aC4gXHJcbiAgICBwcml2YXRlIGRlYm91bmNlcnMgPSBuZXcgTWFwPHN0cmluZywgRGVib3VuY2VyPFtURmlsZSwgc3RyaW5nIHwgbnVsbF0sIHZvaWQ+PigpO1xyXG5cclxuICAgIGFzeW5jIG9ubG9hZCgpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuICAgICAgICAvLyAxLiBDb21tYW5kOiBNYW51YWwgVHJpZ2dlciAoQWN0aXZlIE5vdGUpXHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcclxuICAgICAgICAgICAgaWQ6ICdyZW5hbWUtYXR0YWNobWVudHMtYWN0aXZlJyxcclxuICAgICAgICAgICAgbmFtZTogJ1JlbmFtZSBhdHRhY2htZW50cyBmb3IgYWN0aXZlIG5vdGUnLFxyXG4gICAgICAgICAgICBjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNraW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Njb3BlVmFsaWQoZmlsZS5wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnTm90ZSBpcyBvdXRzaWRlIHRoZSBjb25maWd1cmVkIHNjb3BlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc05vdGVBdHRhY2htZW50cyhmaWxlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gMi4gQ29tbWFuZDogTWFudWFsIFRyaWdnZXIgKEFsbCBOb3RlcyBpbiBTY29wZSlcclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3JlbmFtZS1hdHRhY2htZW50cy1hbGwnLFxyXG4gICAgICAgICAgICBuYW1lOiAnUmVuYW1lIGF0dGFjaG1lbnRzIGZvciBhbGwgbm90ZXMgaW4gc2NvcGUnLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzQWxsTm90ZXNJblNjb3BlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gMy4gU2V0dGluZ3MgVGFiXHJcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBBdHRhY2htZW50U2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xyXG5cclxuICAgICAgICAvLyA0LiBFdmVudDogT24gTm90ZSBSZW5hbWVcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKCdyZW5hbWUnLCAoZmlsZSwgb2xkUGF0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmVuYWJsZUF1dG9SZW5hbWUpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSAmJiBmaWxlLmV4dGVuc2lvbiA9PT0gJ21kJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2NvcGVWYWxpZChmaWxlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZE5vdGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZUZyb21QYXRoKG9sZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJEZWJvdW5jZWRQcm9jZXNzaW5nKGZpbGUsIG9sZE5vdGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tBdHRhY2htZW50IE1hbmFnZXJdIFBsdWdpbiBMb2FkZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBvbnVubG9hZCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlYm91bmNlciBvZiB0aGlzLmRlYm91bmNlcnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZGVib3VuY2VyLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlYm91bmNlcnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0RmlsZU5hbWVGcm9tUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lV2l0aEV4dCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHJldHVybiBmaWxlTmFtZVdpdGhFeHQucmVwbGFjZSgvXFwubWQkLywgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdHJpZ2dlckRlYm91bmNlZFByb2Nlc3NpbmcoZmlsZTogVEZpbGUsIG9sZE5vdGVOYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5kZWJvdW5jZXJzLmdldChmaWxlLnBhdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghZGVib3VuY2VyKSB7XHJcbiAgICAgICAgICAgIGRlYm91bmNlciA9IGRlYm91bmNlKFxyXG4gICAgICAgICAgICAgICAgKGY6IFRGaWxlLCBvbGROYW1lOiBzdHJpbmcgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTm90ZUF0dGFjaG1lbnRzKGYsIG9sZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2Vycy5kZWxldGUoZi5wYXRoKTtcclxuICAgICAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5kZWJvdW5jZURlbGF5LCBcclxuICAgICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZXJzLnNldChmaWxlLnBhdGgsIGRlYm91bmNlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWJvdW5jZXIoZmlsZSwgb2xkTm90ZU5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHByb2Nlc3NBbGxOb3Rlc0luU2NvcGUoKSB7XHJcbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XHJcbiAgICAgICAgY29uc3QgZmlsZXNJblNjb3BlID0gYWxsRmlsZXMuZmlsdGVyKGZpbGUgPT4gdGhpcy5pc1Njb3BlVmFsaWQoZmlsZS5wYXRoKSk7XHJcblxyXG4gICAgICAgIGlmIChmaWxlc0luU2NvcGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIG5vdGVzIGZvdW5kIGluIHRoZSBjb25maWd1cmVkIHNjb3BlJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5ldyBOb3RpY2UoYFByb2Nlc3NpbmcgJHtmaWxlc0luU2NvcGUubGVuZ3RofSBub3Rlcy4uLmApO1xyXG4gICAgICAgIGxldCB0b3RhbFJlbmFtZWQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXNJblNjb3BlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgdGhpcy5wcm9jZXNzTm90ZUF0dGFjaG1lbnRzKGZpbGUsIG51bGwpO1xyXG4gICAgICAgICAgICB0b3RhbFJlbmFtZWQgKz0gY291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuZXcgTm90aWNlKGBcdTI3MDUgUHJvY2Vzc2VkICR7ZmlsZXNJblNjb3BlLmxlbmd0aH0gbm90ZXMsIHJlbmFtZWQgJHt0b3RhbFJlbmFtZWR9IGF0dGFjaG1lbnRzYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWluIExvZ2ljOiBQcm9jZXNzIHRoZSBub3RlIGFuZCByZW5hbWUgaXRzIGVtYmVkcy9saW5rc1xyXG4gICAgICovXHJcbiAgICBhc3luYyBwcm9jZXNzTm90ZUF0dGFjaG1lbnRzKG5vdGVGaWxlOiBURmlsZSwgb2xkTm90ZU5hbWU6IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZy5oYXMobm90ZUZpbGUucGF0aCkpIHJldHVybiAwO1xyXG4gICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nLmFkZChub3RlRmlsZS5wYXRoKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gMS4gU2FmZSBDYWNoZSBSZXRyaWV2YWxcclxuICAgICAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUobm90ZUZpbGUpO1xyXG4gICAgICAgICAgICBsZXQgcmV0cmllcyA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAxMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHdoaWxlICghY2FjaGUgJiYgcmV0cmllcyA8IG1heFJldHJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcclxuICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUobm90ZUZpbGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0cmllcysrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNhY2hlKSByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkUmVmZXJlbmNlcyA9IFtcclxuICAgICAgICAgICAgICAgIC4uLihjYWNoZS5lbWJlZHMgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgLi4uKGNhY2hlLmxpbmtzIHx8IFtdKVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbWJpbmVkUmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xyXG5cclxuICAgICAgICAgICAgLy8gMi4gR2F0aGVyIERhdGFcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0czogQXR0YWNobWVudEluZm9bXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21iaW5lZFJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGNvbWJpbmVkUmVmZXJlbmNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuTGluayA9IHJlZi5saW5rLnNwbGl0KCcjJylbMF0uc3BsaXQoJ14nKVswXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRGaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChjbGVhbkxpbmssIG5vdGVGaWxlLnBhdGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50RmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRGaWxlLmV4dGVuc2lvbiAhPT0gJ21kJyAmJiBcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50RmlsZS5wYXRoICE9PSBub3RlRmlsZS5wYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogYXR0YWNobWVudEZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUGF0aDogYXR0YWNobWVudEZpbGUucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIDMuIFByb2Nlc3MgUmVuYW1lc1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRQYXRocyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IENhY2hlIGZvbGRlcnMgd2Uga25vdyBleGlzdCBzbyB3ZSBkb24ndCBzcGFtIGNoZWNrc1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja2VkRm9sZGVycyA9IG5ldyBTZXQ8c3RyaW5nPigpOyBcclxuICAgICAgICAgICAgbGV0IHJlbmFtZUNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBmaWxlOiBhdHRhY2htZW50RmlsZSwgb3JpZ2luYWxQYXRoLCBpbmRleCB9IG9mIHRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRQYXRocy5oYXMoYXR0YWNobWVudEZpbGUucGF0aCkpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGF0dGFjaG1lbnRGaWxlLnBhdGgpKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlRm9yRXh0ZW5zaW9uKGF0dGFjaG1lbnRGaWxlLmV4dGVuc2lvbik7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFNhZmUgQWxsb3dsaXN0IGFwcHJvYWNoXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUgJiYgdGhpcy5zZXR0aW5ncy5ydWxlcy5sZW5ndGggPiAwKSBjb250aW51ZTsgXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZVBhdHRlcm4gPSBydWxlID8gcnVsZS5uYW1lUGF0dGVybiA6IHRoaXMuc2V0dGluZ3MuZGVmYXVsdE5hbWVQYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aFBhdHRlcm4gPSBydWxlID8gcnVsZS5wYXRoUGF0dGVybiA6IHRoaXMuc2V0dGluZ3MuZGVmYXVsdFBhdGhQYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyA9PT0gTkVXIExPR0lDOiBMb2NhdGlvbiBNb2RlID09PVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcnVsZSBleGlzdHMsIHVzZSBpdHMgbW9kZSwgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gJ3BhdHRlcm4nIChtb3ZlKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb25Nb2RlOiBMb2NhdGlvbk1vZGUgPSBydWxlID8gKHJ1bGUubG9jYXRpb25Nb2RlIHx8ICdwYXR0ZXJuJykgOiAncGF0dGVybic7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5PcmlnaW5hbEJhc2UgPSB0aGlzLmdldENsZWFuT3JpZ2luYWxOYW1lKGF0dGFjaG1lbnRGaWxlLmJhc2VuYW1lLCBvbGROb3RlTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBub3RlRmlsZS5iYXNlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogY2xlYW5PcmlnaW5hbEJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBhdHRhY2htZW50RmlsZS5leHRlbnNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogdGhpcy5nZXRGb3JtYXR0ZWREYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IChpbmRleCArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3QmFzZU5hbWUgPSB0aGlzLnNhbml0aXplTmFtZSh0aGlzLmFwcGx5VmFyaWFibGVzKG5hbWVQYXR0ZXJuLCB2YXJpYWJsZXMpKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdCYXNlTmFtZS5sZW5ndGggPT09IDApIG5ld0Jhc2VOYW1lID0gJ2F0dGFjaG1lbnQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7bmV3QmFzZU5hbWV9LiR7YXR0YWNobWVudEZpbGUuZXh0ZW5zaW9ufWA7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vID09PSBMT0dJQzogRGV0ZXJtaW5lIFRhcmdldCBGb2xkZXIgPT09XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0Rm9sZGVyUGF0aDogc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb25Nb2RlID09PSAnb3JpZ2luYWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT1BUSU9OOiBMZWF2ZSBhcyBpcyAoS2VlcCBpbiBjdXJyZW50IHBhcmVudCBmb2xkZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Rm9sZGVyUGF0aCA9IGF0dGFjaG1lbnRGaWxlLnBhcmVudCA/IGF0dGFjaG1lbnRGaWxlLnBhcmVudC5wYXRoIDogJy8nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPUFRJT046IE1vdmUgdXNpbmcgUGF0dGVybiAoZS5nLiAuL3RlbXBsYXRlcylcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRGb2xkZXJQYXRoID0gdGhpcy5yZXNvbHZlVGFyZ2V0UGF0aChwYXRoUGF0dGVybiwgbm90ZUZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRQYXRoID0gbm9ybWFsaXplUGF0aChgJHt0YXJnZXRGb2xkZXJQYXRofS8ke25ld0ZpbGVOYW1lfWApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkUGF0aCA9PT0gYXR0YWNobWVudEZpbGUucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZFBhdGhzLmFkZChhdHRhY2htZW50RmlsZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFBhdGggPSBhd2FpdCB0aGlzLnJlc29sdmVDb2xsaXNpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzaXJlZFBhdGgsIFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRGaWxlLCBcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRGb2xkZXJQYXRoLCBcclxuICAgICAgICAgICAgICAgICAgICBuZXdCYXNlTmFtZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxQYXRoID09PSBhdHRhY2htZW50RmlsZS5wYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkUGF0aHMuYWRkKGF0dGFjaG1lbnRGaWxlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBPbmx5IGNoZWNrIGZvbGRlciBleGlzdGVuY2UgaWYgd2UgaGF2ZW4ndCBjaGVja2VkIHRoaXMgZm9sZGVyIGluIHRoaXMgYmF0Y2hcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRGb2xkZXJzLmhhcyh0YXJnZXRGb2xkZXJQYXRoKSAmJiBsb2NhdGlvbk1vZGUgIT09ICdvcmlnaW5hbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXJFeGlzdHModGFyZ2V0Rm9sZGVyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWRGb2xkZXJzLmFkZCh0YXJnZXRGb2xkZXJQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtBdHRhY2htZW50IE1hbmFnZXJdIFJlbmFtaW5nOiAke2F0dGFjaG1lbnRGaWxlLm5hbWV9IC0+ICR7ZmluYWxQYXRofWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnJlbmFtZUZpbGUoYXR0YWNobWVudEZpbGUsIGZpbmFsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkUGF0aHMuYWRkKGZpbmFsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtBdHRhY2htZW50IE1hbmFnZXJdIEVycm9yIHJlbmFtaW5nICR7b3JpZ2luYWxQYXRofWAsIGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZW5hbWVDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQXR0YWNobWVudCBNYW5hZ2VyXSBSZW5hbWVkICR7cmVuYW1lQ291bnR9IGZpbGVzIGZvciAke25vdGVGaWxlLmJhc2VuYW1lfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZW5hbWVDb3VudDtcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0F0dGFjaG1lbnQgTWFuYWdlcl0gRXJyb3I6XCIsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZy5kZWxldGUobm90ZUZpbGUucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldENsZWFuT3JpZ2luYWxOYW1lKGN1cnJlbnRCYXNlOiBzdHJpbmcsIG9sZE5vdGVOYW1lOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoIW9sZE5vdGVOYW1lKSByZXR1cm4gY3VycmVudEJhc2U7XHJcbiAgICAgICAgbGV0IGNsZWFuID0gY3VycmVudEJhc2U7XHJcbiAgICAgICAgaWYgKGNsZWFuLmluY2x1ZGVzKG9sZE5vdGVOYW1lKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlc2NhcGVkT2xkID0gb2xkTm90ZU5hbWUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgW1xcXFxzLV9dKiR7ZXNjYXBlZE9sZH1bXFxcXHMtX10qYCwgJ2cnKTtcclxuICAgICAgICAgICAgY2xlYW4gPSBjbGVhbi5yZXBsYWNlKHJlZ2V4LCAnICcpLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsZWFuID09PSAnJykgY2xlYW4gPSAnQXR0YWNobWVudCc7IFxyXG4gICAgICAgIHJldHVybiBjbGVhbjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc29sdmVUYXJnZXRQYXRoKHBhdGhQYXR0ZXJuOiBzdHJpbmcsIG5vdGVGaWxlOiBURmlsZSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHBhdGhQYXR0ZXJuLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IG5vdGVGaWxlLnBhcmVudCA/IG5vdGVGaWxlLnBhcmVudC5wYXRoIDogJy8nO1xyXG4gICAgICAgICAgICBjb25zdCBjbGVhblJlbCA9IHBhdGhQYXR0ZXJuLnN1YnN0cmluZygyKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFBhdGggPT09ICcvJykgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoY2xlYW5SZWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChgJHtwYXJlbnRQYXRofS8ke2NsZWFuUmVsfWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVQYXRoKHBhdGhQYXR0ZXJuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyByZXNvbHZlQ29sbGlzaW9uKFxyXG4gICAgICAgIGRlc2lyZWRQYXRoOiBzdHJpbmcsIFxyXG4gICAgICAgIGN1cnJlbnRGaWxlOiBURmlsZSxcclxuICAgICAgICB0YXJnZXRGb2xkZXI6IHN0cmluZyxcclxuICAgICAgICBiYXNlTmFtZTogc3RyaW5nXHJcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGxldCBmaW5hbFBhdGggPSBkZXNpcmVkUGF0aDtcclxuICAgICAgICBsZXQgc3VmZml4ID0gMDtcclxuICAgICAgICBjb25zdCBtYXhSZXRyaWVzID0gNTAwO1xyXG4gICAgICAgIGNvbnN0IGV4dCA9IGN1cnJlbnRGaWxlLmV4dGVuc2lvbjtcclxuXHJcbiAgICAgICAgd2hpbGUgKHN1ZmZpeCA8IG1heFJldHJpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmluYWxQYXRoKTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuIGZpbmFsUGF0aDtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nLnBhdGggPT09IGN1cnJlbnRGaWxlLnBhdGgpIHJldHVybiBmaW5hbFBhdGg7XHJcblxyXG4gICAgICAgICAgICBzdWZmaXgrKztcclxuICAgICAgICAgICAgZmluYWxQYXRoID0gbm9ybWFsaXplUGF0aChgJHt0YXJnZXRGb2xkZXJ9LyR7YmFzZU5hbWV9ICR7c3VmZml4fS4ke2V4dH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRGaWxlLnBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgaXNTY29wZVZhbGlkKGZpbGVQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCB7IHNjb3BlTW9kZSwgd2F0Y2hlZFBhdGhzIH0gPSB0aGlzLnNldHRpbmdzO1xyXG4gICAgICAgIGlmIChzY29wZU1vZGUgPT09ICd2YXVsdCcpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlUGF0aCA9IG5vcm1hbGl6ZVBhdGgoZmlsZVBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkV2F0Y2hlZFBhdGhzID0gd2F0Y2hlZFBhdGhzXHJcbiAgICAgICAgICAgIC5tYXAocCA9PiBub3JtYWxpemVQYXRoKHApKVxyXG4gICAgICAgICAgICAuZmlsdGVyKHAgPT4gcCAhPT0gJycgJiYgcCAhPT0gJy8nKTtcclxuICAgICAgICBpZiAodmFsaWRXYXRjaGVkUGF0aHMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjb25zdCBpc01hdGNoID0gdmFsaWRXYXRjaGVkUGF0aHMuc29tZShmb2xkZXIgPT4gXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRGaWxlUGF0aCA9PT0gZm9sZGVyIHx8IG5vcm1hbGl6ZWRGaWxlUGF0aC5zdGFydHNXaXRoKGZvbGRlciArICcvJylcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzY29wZU1vZGUgPT09ICdpbmNsdWRlJykgcmV0dXJuIGlzTWF0Y2g7XHJcbiAgICAgICAgaWYgKHNjb3BlTW9kZSA9PT0gJ2V4Y2x1ZGUnKSByZXR1cm4gIWlzTWF0Y2g7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UnVsZUZvckV4dGVuc2lvbihleHQ6IHN0cmluZyk6IEF0dGFjaG1lbnRSdWxlIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJFeHQgPSBleHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5ydWxlcy5maW5kKHIgPT4gXHJcbiAgICAgICAgICAgIHIuZXh0ZW5zaW9ucy5zb21lKGUgPT4gZS50b0xvd2VyQ2FzZSgpID09PSBsb3dlckV4dClcclxuICAgICAgICApIHx8IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgYXBwbHlWYXJpYWJsZXMocGF0dGVybjogc3RyaW5nLCB2YXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVyblxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwkXFx7ZmlsZW5hbWVcXH0vZywgdmFycy5maWxlbmFtZSB8fCAnbm90ZScpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCRcXHtvcmlnaW5hbFxcfS9nLCB2YXJzLm9yaWdpbmFsIHx8ICdmaWxlJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJFxce2V4dGVuc2lvblxcfS9nLCB2YXJzLmV4dGVuc2lvbiB8fCAnJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJFxce2RhdGVcXH0vZywgdmFycy5kYXRlIHx8ICcnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwkXFx7aW5kZXhcXH0vZywgdmFycy5pbmRleCB8fCAnMDEnKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEZvcm1hdHRlZERhdGUoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zdCB5ZWFyID0gZC5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIGNvbnN0IG1vbnRoID0gKGQuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgICBjb25zdCBkYXkgPSBkLmdldERhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgICAgcmV0dXJuIGAke3llYXJ9JHttb250aH0ke2RheX1gO1xyXG4gICAgfVxyXG5cclxuICAgIHNhbml0aXplTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL1tcXFxcLzpcIio/PD58XSsvZywgJy0nKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGVuc3VyZUZvbGRlckV4aXN0cyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIXBhdGggfHwgcGF0aCA9PT0gJy8nIHx8IHBhdGggPT09ICcuJykgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQYXRoKHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBURm9sZGVyKSByZXR1cm47XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSBmb2xkZXIgXCIke25vcm1hbGl6ZWR9XCIgYmVjYXVzZSBhIGZpbGUgZXhpc3RzIHdpdGggdGhhdCBuYW1lLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIobm9ybWFsaXplZCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG4gICAgICAgIGNvbnN0IGxvYWRlZCA9IGF3YWl0IHRoaXMubG9hZERhdGEoKTtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgbG9hZGVkKTtcclxuICAgICAgICBpZiAobG9hZGVkPy5ydWxlcykge1xyXG4gICAgICAgICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBlbnN1cmUgbG9jYXRpb25Nb2RlIGV4aXN0c1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnJ1bGVzID0gbG9hZGVkLnJ1bGVzLm1hcCgocjogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgLi4ucixcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uTW9kZTogci5sb2NhdGlvbk1vZGUgfHwgJ3BhdHRlcm4nIFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2FkZWQ/LndhdGNoZWRQYXRocykgdGhpcy5zZXR0aW5ncy53YXRjaGVkUGF0aHMgPSBsb2FkZWQud2F0Y2hlZFBhdGhzO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyAtLS0gU2V0dGluZ3MgVUkgLS0tXHJcblxyXG5jbGFzcyBBdHRhY2htZW50U2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gICAgcGx1Z2luOiBBdHRhY2htZW50TWFuYWdlclBsdWdpbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBBdHRhY2htZW50TWFuYWdlclBsdWdpbikge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnQXR0YWNobWVudCBNYW5hZ2VyJyB9KTtcclxuXHJcbiAgICAgICAgLy8gR2VuZXJhbFxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0dlbmVyYWwnIH0pO1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRW5hYmxlIEF1dG8tUmVuYW1lJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlQXV0b1JlbmFtZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlQXV0b1JlbmFtZSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZWJvdW5jZSBEZWxheSAobXMpJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJzIwMDAnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJvdW5jZURlbGF5KSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG51bSkgJiYgbnVtID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVib3VuY2VEZWxheSA9IG51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBTY29wZVxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1Njb3BlJyB9KTtcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ09wZXJhdGlvbiBNb2RlJylcclxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3AgPT4gZHJvcFxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbigndmF1bHQnLCAnRW50aXJlIFZhdWx0JylcclxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ2luY2x1ZGUnLCAnT25seSBpbiBXYXRjaGVkIEZvbGRlcnMnKVxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignZXhjbHVkZScsICdFdmVyeXdoZXJlIEVYQ0VQVCBJZ25vcmVkIEZvbGRlcnMnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNjb3BlTW9kZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2NvcGVNb2RlID0gdmFsIGFzIFNjb3BlTW9kZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zY29wZU1vZGUgIT09ICd2YXVsdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zY29wZU1vZGUgPT09ICdpbmNsdWRlJyA/ICdXYXRjaGVkIEZvbGRlcnMnIDogJ0lnbm9yZWQgRm9sZGVycyc7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUobGFiZWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnT25lIGZvbGRlciBwYXRoIHBlciBsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1Byb2plY3RzL0FjdGl2ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLndhdGNoZWRQYXRocy5qb2luKCdcXG4nKSlcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy53YXRjaGVkUGF0aHMgPSB2YWwuc3BsaXQoJ1xcbicpLm1hcCh4ID0+IHgudHJpbSgpKS5maWx0ZXIoeCA9PiB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUnVsZXNcclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdFeHRlbnNpb24gUnVsZXMnIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZvckVhY2goKHJ1bGUsIGlkeCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlRGl2ID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCk7XHJcbiAgICAgICAgICAgIHJ1bGVEaXYuc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciknO1xyXG4gICAgICAgICAgICBydWxlRGl2LnN0eWxlLnBhZGRpbmcgPSAnMTBweCAwJztcclxuXHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKHJ1bGVEaXYpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShgUnVsZSAjJHtpZHggKyAxfWApXHJcbiAgICAgICAgICAgICAgICAuc2V0SGVhZGluZygpXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ0biA9PiBidG5cclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbigndHJhc2gnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRXYXJuaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgbmV3IFNldHRpbmcocnVsZURpdikuc2V0TmFtZSgnTGFiZWwnKS5hZGRUZXh0KHQgPT4gdC5zZXRWYWx1ZShydWxlLmxhYmVsKS5vbkNoYW5nZShhc3luYyB2ID0+IHsgcnVsZS5sYWJlbCA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyB9KSk7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKHJ1bGVEaXYpLnNldE5hbWUoJ0V4dGVuc2lvbnMnKS5zZXREZXNjKCdlLmcuIHBuZywganBnJykuYWRkVGV4dCh0ID0+IHQuc2V0VmFsdWUocnVsZS5leHRlbnNpb25zLmpvaW4oJywgJykpLm9uQ2hhbmdlKGFzeW5jIHYgPT4geyBcclxuICAgICAgICAgICAgICAgIHJ1bGUuZXh0ZW5zaW9ucyA9IHYuc3BsaXQoJywnKS5tYXAoZSA9PiBlLnRyaW0oKSkuZmlsdGVyKGUgPT4gZSk7IFxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7IFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyAtLS0gTkVXOiBMb2NhdGlvbiBNb2RlIERyb3Bkb3duIC0tLVxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhydWxlRGl2KVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ0xvY2F0aW9uIFN0cmF0ZWd5JylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdNb3ZlIGZpbGUgdG8gcGF0dGVybiBmb2xkZXIgT1IgbGVhdmUgd2hlcmUgaXQgaXMuJylcclxuICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wID0+IGRyb3BcclxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdwYXR0ZXJuJywgJ01vdmUgdG8gRGVmaW5lZCBQYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdvcmlnaW5hbCcsICdMZWF2ZSBpbiBPcmlnaW5hbCBGb2xkZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShydWxlLmxvY2F0aW9uTW9kZSB8fCAncGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5sb2NhdGlvbk1vZGUgPSB2YWwgYXMgTG9jYXRpb25Nb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVmcmVzaCB0byBzaG93L2hpZGUgcGF0aCBwYXR0ZXJuIGlmIG5lZWRlZCwgdGhvdWdoIHNpbXBsZXIgdG8ga2VlcCBVSSBzdGF0aWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBzaG93IFBhdGggUGF0dGVybiBpZiBtb2RlIGlzICdwYXR0ZXJuJ1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGUubG9jYXRpb25Nb2RlIHx8IHJ1bGUubG9jYXRpb25Nb2RlID09PSAncGF0dGVybicpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKHJ1bGVEaXYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0xvY2F0aW9uIFBhdHRlcm4nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdVc2UgXCIuL1wiIGZvciByZWxhdGl2ZSBwYXRoLiAoZS5nLiAuL3RlbXBsYXRlcyknKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KHQgPT4gdC5zZXRWYWx1ZShydWxlLnBhdGhQYXR0ZXJuKS5vbkNoYW5nZShhc3luYyB2ID0+IHsgcnVsZS5wYXRoUGF0dGVybiA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKHJ1bGVEaXYpLnNldE5hbWUoJ05hbWUgUGF0dGVybicpLmFkZFRleHQodCA9PiB0LnNldFZhbHVlKHJ1bGUubmFtZVBhdHRlcm4pLm9uQ2hhbmdlKGFzeW5jIHYgPT4geyBydWxlLm5hbWVQYXR0ZXJuID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7IH0pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnRuID0+IGJ0blxyXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJysgQWRkIFJ1bGUnKVxyXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnTmV3IFJ1bGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVBhdHRlcm46ICcke2ZpbGVuYW1lfSAke29yaWdpbmFsfScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhQYXR0ZXJuOiAnLi9hdHRhY2htZW50cycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uTW9kZTogJ3BhdHRlcm4nIC8vIERlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlz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
